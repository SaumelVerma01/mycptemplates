/*▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▄░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░██▌░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░▄▄███▀░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░█████░▄█░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░▄████████▀░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒▒░░░░░░░░░░░░░░░░░░░░░░░░▄█████████░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒░░░░░░░░░░░░░░░░░░░░░░░░░░▄███████▌░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒░░░░░░░░░░░░░░░░░░░░░░░░▄█████████░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒░░░░░░░░░░░░░░░░░░░░░▄███████████▌░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒░░░░░░░░░░░░░░░▄▄▄▄██████████████▌░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒░░░░░░░░░░░▄▄███████████████████▌░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒░░░░░░░░░▄██████████████████████▌░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒░░░░░░░░████████████████████████░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒█░░░░░▐██████████▌░▀▀███████████░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▐██░░░▄██████████▌░░░░░░░░░▀██▐█▌░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒██████░█████████ ░░░░░░░░░░▐█▐█▌░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒▒▀▀▀▀░░░██████▀░░░░░░░░░░░░▐█▐█▌░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒▒▒▒▒░░░░▐█████▌░░░░░░░░░░░░▐█▐█▌░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒▒▒▒▒▒░░░░███▀██░░░░░░░░░░░░░█░█▌░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒▒▒▒▒▒▒▒░▐██░░░██░░░░░░░░▄▄████████▄▄▄▄▄▄▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒▒▒▒▒▒▒▒▒██▌░░░░█▄░░░░░░▄███████████████████▄▄▄▄▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒▒▒▒▒▒▒▒▒▐██▒▒░░░██▄▄████████████████████████████████████████████
▒▒▒▒▒▒▒▒▒▒▐██▒▒▄█████████████████████████████████████████████████
▒▒▒▒▒▒▒▒▒▒▄▄█████████████████████████████████████████████████████
█████████████████████████████████████████████████████████████████*/
#include <bits/stdc++.h>
using namespace std;
#define  w(t)                      int t;  cin>>t;  while(t--)
#define  mod1                      1000000007
#define  mod2                      998244353
#define  ll                        long long int
#define  ull                       unsigned long long int
#define  fastIO                    ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);
#define  vll                       vector<ll>
#define  vi                        vector<int>
#define  vch                       vector<char>
#define  pll                       pair<ll,ll>
#define  pii                       pair<int,int>
#define  makpii                    make_pair
#define  mpii                      unordered_map<int,int>
#define  sti                       unordered_set<int>
#define  mpci                      unordered_map<char,int>
template<typename T>
T myMax(T x, T y)
{
    return (x > y) ? x : y;
}
struct myComp1          //      sort pairs by second element (MAX)
{
    constexpr bool operator()
    (pair<ll, ll> const& a, pair<ll, ll> const& b)const noexcept
    {
        return a.second < b.second;
    }
};
struct myComp2          //      sort pairs by second element (MIN)
{
    constexpr bool operator()
    (pair<ll, ll> const& a, pair<ll, ll> const& b)const noexcept
    {
        return a.second > b.second;
    }
};
priority_queue<pll, vector<pll>, myComp1> p1; // priority queue with second element in MAX order
priority_queue<pll, vector<pll>, myComp2> p2; // priority queue with second element in MIN order

int32_t main()
{
    fastIO
#ifndef ONLINE_JUDGE
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);
#endif
    w(t)
    {
        cout << "TEST";
    }
    return 0;
}
/*
bool prime[1000001];
int primebeh[1000001];
int primesnear[1000001];
void sieve()
{
    int n = 1000000;
    memset(prime, true, sizeof(prime));
    prime[1]=false;
    for (int p = 2; p * p <= n; p++)
    {
        if (prime[p] == true)
        {
            for (int i = p * p; i <= n; i += p)
                prime[i] = false;
        }
    }
    int last = 0;
    for (int i = 2; i <= n; i++)
    {
        if (prime[i])
        {
            primesnear[i] = i;
            last = i;
        }
        else
        {
            primesnear[i] = last;
        }
    }
    for (int i = n; i >= 2; i--)
    {
        if (prime[i])
        {
            primebeh[i] = i;
            last = i;
        }
        else
        {
            primebeh[i] = last;
        }
    }
}
ll power(ll x, ll y, ll p)
{
    ll res = 1; x = x % p; while (y > 0) {if (y & 1) {res = (res * x) % p;} y = y >> 1; x = (x * x) % p;}
    return res;
}
ll modInverse(ll n, int p)
{
    return power(n, p - 2, p);
}
ll nCrModPFermat(ll n, ll r, ll p)
{
    if (n < r)
        return 0;
    if (r == 0)
        return 1;
    ll fac[n + 1];
    fac[0] = 1;
    for (int i = 1; i <= 1000; i++)
        fac[i] = (fac[i - 1] * i) % mod2;
    return (fac[n] * modInverse(fac[r], p) % p * modInverse(fac[n - r], p) % p) % p;
}
}
vector<pair<int, int>> pf;
void factorize(int n) // finds all prime factors of n and their powers in O(logn)
{
    pf.clear();
    int ct = 0;
    while (n % 2 == 0)
    {
        n /= 2;
        ct++;
    }
    if (ct)
        pf.push_back({2, ct});
    for (int i = 3; i * i <= n; i += 2)
    {
        ct = 0;
        while (n % i == 0)
        {
            n /= i;
            ct++;
        }
        if (ct)
            pf.push_back({i, ct});
    }
    if (n > 2)
        pf.push_back({n, 1});
}
*/
/*int parent[200005]; DSU
int sz[200005];
void maker_set(int u)
{
    parent[u] = u;
    sz[u] = 1;
}
int find_set(int u)
{
    if (u == parent[u])
        return u;
    return parent[u] = find_set(parent[u]);
}
void union_set(int u, int v)
{
    int a = find_set(u);
    int b = find_set(v);
    if (a != b)
    {
        if (sz[a] < sz[b])
            swap(a, b);
        parent[b] = a;
        sz[a] = sz[a] + sz[b];
    }
}*/
/*const int MAXN = 500005;
int n, q, t[4 * MAXN];
void build(int a[], int v, int l, int r) // O(n) SEGMENT TREE
{
    if (l == r)
    {
        t[v] = a[l];
    }
    else
    {
        int m = (l + r) / 2;
        build(a, 2 * v, l, m);
        build(a, 2 * v + 1, m + 1, r);
        t[v] = t[2 * v] + t[2 * v + 1];
    }
}
int sum(int v, int tl, int tr, int l, int r) // O(logn)
{
    if (l > r)
        return 0;
    if (l == tl && r == tr)
        return t[v];
    int tm = (tl + tr) / 2;
    return sum(2 * v, tl, tm, l, min(r, tm)) + sum(2 * v + 1, tm + 1, tr, max(l, tm + 1), r);
}
void update(int v, int tl, int tr, int pos, int val) // O(logn)
{
    if (tl == tr)
    {
        t[v] += val;
    }
    else
    {
        int tm = (tl + tr) / 2;
        if (pos <= tm)
            update(2 * v, tl, tm, pos, val);
        else
            update(2 * v + 1, tm + 1, tr, pos, val);
        t[v] = t[2 * v] + t[2 * v + 1];
    }
}*/
/*
#define MAXSIEVE 100000000 // All prime numbers up to this  Yarin sieve
#define MAXSIEVEHALF (MAXSIEVE/2)
#define MAXSQRT 5000 // sqrt(MAXSIEVE)/2
char a[MAXSIEVE / 16 + 2];
#define isprime(n) (a[(n)>>4]&(1<<(((n)>>1)&7))) // Works when n is odd
//have to check for even numbers
void sieve()
{
    int i, j;
    memset(a, 255, sizeof(a));
    a[0] = 0xFE;
    for (i = 1; i < MAXSQRT; i++)
        if (a[i >> 3] & (1 << (i & 7)))
            for (j = i + i + i + 1; j < MAXSIEVEHALF; j += i + i + 1)
                a[j >> 3] &= ~(1 << (j & 7));
}
struct DSU {
    vector<int> parent;
    vector<int> sz;
    DSU(int N) {
        parent.resize(2 * N + 5);
        sz.resize(2 * N + 5, 1);
        iota(parent.begin(), parent.end(), 0);
    }
    int find_set(int U) {
        if (U == parent[U])
            return U;
        return parent[U] = find_set(parent[U]);
    }
    void union_set(int U, int V) {
        int A = find_set(U);
        int B = find_set(V);
        if (A != B) {
            if (sz[A] < sz[B])
                swap(A, B);
            parent[B] = A;
            sz[A] = sz[A] + sz[B];
        }
    }
};
vector<int> adj[200005];
bool visited[200005];
set<int> atdepth[200005];
const int sz = 2e5 + 5;
vector<int> tree[sz];
bool vis[sz];
set<int> path[sz];
void addEdge(int a, int b)
{
    tree[a].push_back(b);
    tree[b].push_back(a);
}
void bfs(int node) // get all paths from root to the node
{
    queue<pair<int, int> > qu;
    qu.push({ node, -1 });
    vis[node] = true;
    while (!qu.empty())
    {
        pair<int, int> p = qu.front();
        qu.pop();
        vis[p.first] = true;
        for (int child : tree[p.first])
        {
            if (!vis[child])
            {
                qu.push({ child, p.first });
                path[child] = path[p.first];
                path[child].insert(p.first);
            }
        }
    }
}
void dfs(int x, int c) // mark all nodes at same depth
{
    visited[x] = true;
    atdepth[c].insert(x);
    for (auto y : adj[x])
    {
        if (!visited[y])
        {
            dfs(y, c + 1);
        }
    }
    if (adj[x].size() == 0)
        atdepth[c].insert(x);
    return;
}*/
/*struct myComp1 //      sort pairs by second element (MAX)
{
    constexpr bool operator()(pair<int, int> const &a, pair<int, int> const &b) const noexcept
    {
        return a.second < b.second;
    }
};
struct myComp2 //      sort pairs by second element (MIN)
{
    constexpr bool operator()(pair<int, int> const &a, pair<int, int> const &b) const noexcept
    {
        return a.second > b.second;
    }
};
struct custom_hash
{
    static uint64_t splitmix64(uint64_t x)
    {
        // http://xorshift.di.unimi.it/splitmix64.c
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }
    size_t operator()(uint64_t x) const
    {
        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x + FIXED_RANDOM);
    }
};
priority_queue<pair<int,int>, vector<pair<int,int>>, myComp1> p1; // priority queue with second element in MAX order
priority_queue<pair<int,int>, vector<pair<int,int>>, myComp2> p2; // priority queue with second element in MIN order*/
/*int ceili(int a, int b)
{
    return a % b == 0 ? (a / b) : (a / b) + 1;
}
int gcd(int a, int b)
{
    if (!a)
        return b;
    return gcd(b % a, a);
}
int power(int x, int y, int p)
{
    int res = 1LL;
    x = x % p;
    while (y > 0)
    {
        if (y & 1)
        {
            res = (res * x) % p;
        }
        y = y >> 1;
        x = (x * x) % p;
    }
    return res;
}
void printVector(vector<int> &vt)
{
    for (auto x : vt)
    {
        cout << x << " ";
    }
    cout << "\n";
}
bool checkpal(string s)
{
    int n = s.length();
    for (int i = 0; i < n; i++)
    {
        if (s[i] != s[n - i - 1])
        {
            return false;
        }
    }
    return true;
}
to check if a point is on in or out of a polygon time complexity O(N)
struct Point
{
    int x;
    int y;
};
bool onSegment(Point p, Point q, Point r)
{
    if (q.x <= max(p.x, r.x) && q.x >= min(p.x, r.x) && q.y <= max(p.y, r.y) && q.y >= min(p.y, r.y))
    {
        return true;
    }
    return false;
}
int orientation(Point p, Point q, Point r)
{
    int val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    if (val == 0)
    {
        return 0;
    }
    return (val > 0) ? 1 : 2;
}
bool doIntersect(Point p1, Point q1, Point p2, Point q2)
{
    int o1 = orientation(p1, q1, p2);
    int o2 = orientation(p1, q1, q2);
    int o3 = orientation(p2, q2, p1);
    int o4 = orientation(p2, q2, q1);
    if (o1 != o2 && o3 != o4)
        return true;
    if (o1 == 0 && onSegment(p1, p2, q1))
    {
        return true;
    }
    if (o2 == 0 && onSegment(p1, q2, q1))
    {
        return true;
    }
    if (o3 == 0 && onSegment(p2, p1, q2))
    {
        return true;
    }
    if (o4 == 0 && onSegment(p2, q1, q2))
    {
        return true;
    }
    return false;
}
bool isInside(Point polygon[], int n, Point p)
{
    if (n < 3)
    {
        return false;
    }
    Point extreme = {INF, p.y};
    int count = 0, i = 0;
    do
    {
        int next = (i + 1) % n;
        if (doIntersect(polygon[i], polygon[next], p, extreme))
        {
            if (orientation(polygon[i], p, polygon[next]) == 0)
                return onSegment(polygon[i], p, polygon[next]);
            count++;
        }
        i = next;
    } while (i != 0);
    return count & 1;
}
struct SparseTable {
    int n, k;
    vector<vector<int64_t>> M;
    vector<int64_t> Log;
    SparseTable(int n) {
        this->n = n;
        this->k = ceil(log2(n)) + 1;
        M.assign(n + 1, vector<int64_t> (k + 1, 0));
        Log.assign(n + 5, 0);
        Log[1] = 0;
        for (int i = 2; i <= n; i++) {
            Log[i] = Log[i / 2] + 1;
        }
    }
    void computationFisMin(vector<int64_t> a) {
        for (int i = 0; i < n; i++) {
            M[i][0] = a[i];
        }
        for (int j = 1; j <= k; j++) {
            for (int i = 0; i + (1 << j) <= n; i++) {
                M[i][j] = min(M[i][j - 1], M[i + (1 << (j - 1))][j - 1]);
            }
        }
    }
    void computationFisSum(vector<int64_t> a) {
        for (int i = 0; i < n; i++) {
            M[i][0] = a[i];
        }
        for (int j = 1; j <= k; j++) {
            for (int i = 0; i + (1 << j) <= n; i++) {
                M[i][j] = (M[i][j - 1] + M[i + (1 << (j - 1))][j - 1]);
            }
        }
    }
    int64_t MinQuery(int l, int r) {
        int j = Log[r - l + 1];
        return min(M[l][j], M[r - (1 << j) + 1][j]);
    }
    int64_t SumQuery(int l, int r) {
        int64_t sum = 0;
        for (int j = k; j >= 0; j--) {
            if ((1 << j) <= (r - l + 1)) {
                sum += M[l][j];
                l += (1 << j);
            }
        }
        return sum;
    }
};
struct FenwickTree {
    vector<int64_t> bit;
    int n;
    FenwickTree(int n) { // O(N)
        this->n = n;
        bit.assign(n, 0);
    }
    FenwickTree(vector<int64_t> a) : FenwickTree(a.size()) {
        for (auto i = 0; i < a.size(); i++) {
            add(i, a[i]);
        }
    }
    int64_t sum(int r) { // O(logN)
        int64_t res = 0;
        for (; r >= 0; r = (r & (r + 1)) - 1) {
            res += bit[r];
        }
        return res;
    }
    int64_t sum(int l, int r) {
        if (l == 0)
            return sum(r);
        else
            return (sum(r) - sum(l - 1));
    }
    void add(int idx, int delta) { // O(logN)
        for (; idx < n; idx = idx | (idx + 1)) {
            bit[idx] += delta;
        }
    }
};
struct SegmentTree {
    int n;
    vector<int64_t> T;
    SegmentTree(int n) {
        this->n = n;
        T.assign(2 * n + 5, 0);
    }
    void UpdateforMin(int k, int x) {
        k += n;
        T[k] = x;
        k = k >> 1;
        while (k >= 1) {
            T[k] = min(T[2 * k], T[2 * k + 1]);
            k = k >> 1;
        }
    }
    void UpdateforSum(int k, int x) {
        k += n;
        x = x - T[k];
        while (k >= 1) {
            T[k] += x;
            k = k >> 1;
        }
    }
    int64_t QueryforSum(int l, int r) {
        l += n; r += n;
        int64_t S = 0;
        while (l <= r) {
            if (l & 1) {
                S += T[l++];
            }
            if (~r & 1) {
                S += T[r--];
            }
            l = l >> 1; r = r >> 1;
        }
        return S;
    }
    int64_t QueryforMin(int l, int r) {
        l += n; r += n;
        int64_t S = INT_MAX;
        while (l <= r) {
            if (l & 1) {
                S = min(S, T[l++]);
            }
            if (~r & 1) {
                S = min(S, T[r--]);
            }
            l = l >> 1; r = r >> 1;
        }
        return S;
    }
};
struct choose {
    int64_t N_;
    vector<int64_t> factorialNumInverse;
    vector<int64_t> naturalNumInverse;
    vector<int64_t> fact;
    choose (int64_t N_) {
        this->N_ = N_;
        factorialNumInverse.assign(N_ + 1, 0);
        naturalNumInverse.assign(N_ + 1, 0);
        fact.assign(N_ + 1, 0);
    }
    void InverseofNumber(int64_t p)
    {
        naturalNumInverse[0] = naturalNumInverse[1] = 1;
        for (int64_t i = 2; i <= N_; i++) {
            naturalNumInverse[i] = naturalNumInverse[p % i] * (p - p / i) % p;
        }
    }
    void InverseofFactorial(int64_t p)
    {
        factorialNumInverse[0] = factorialNumInverse[1] = 1;
        for (int64_t i = 2; i <= N_; i++) {
            factorialNumInverse[i] = (naturalNumInverse[i] * factorialNumInverse[i - 1]) % p;
        }
    }
    void factorial(int64_t p)
    {
        fact[0] = 1;
        for (int64_t i = 1; i <= N_; i++) {
            fact[i] = (fact[i - 1] * i) % p;
        }
    }
    int64_t Binomial(int64_t N, int64_t R, int64_t p)
    {
        int64_t ans = ((fact[N] * factorialNumInverse[R]) % p * factorialNumInverse[N - R]) % p;
        return ans;
    }
};
class LRUCache {
private:
    list<pair<int, int>> lst;
    unordered_map<int, list<pair<int, int>>::iterator> mp;
    int n;
public:
    LRUCache(int cap) {
        this->n = cap;
    }
    int get(int key) {
        if (mp.find(key) == mp.end()) {
            return -1;
        }
        auto it = mp[key];
        int value = it->second;
        lst.erase(it);
        lst.push_front({key, value});
        mp[key] = lst.begin();
        return value;
    }
    void set(int key, int value) {
        if (mp.find(key) == mp.end()) {
            if (lst.size() == n) {
                auto least_used = lst.back();
                mp.erase(least_used.first);
                lst.pop_back();
            }
        }
        else {
            auto it = mp[key];
            lst.erase(it);
        }
        lst.push_front({key, value});
        mp[key] = lst.begin();
    }
};
int64_t pow2lessthanequal(int64_t n) {
    int64_t res = n;
    while ((res & (res - 1))) {
        res = (res & (res - 1));
    }
    return res;
}
int64_t pow2greaterthanequal(int64_t n) {
    int64_t res = n;
    while ((res & (res - 1))) {
        res = (res & (res - 1));
    }
    if (res != n)
        res <<= 1;
    return res;
}
// Tourist's Modular Class
template <typename T>
T inverse(T a, T m) {
    T u = 0, v = 1;
    while (a != 0) {
        T t = m / a;
        m -= t * a; swap(a, m);
        u -= t * v; swap(u, v);
    }
    assert(m == 1);
    return u;
}
template <typename T>
class Modular {
public:
    using Type = typename decay<decltype(T::value)>::type;

    constexpr Modular() : value() {}
    template <typename U>
    Modular(const U& x) {
        value = normalize(x);
    }

    template <typename U>
    static Type normalize(const U& x) {
        Type v;
        if (-mod() <= x && x < mod()) v = static_cast<Type>(x);
        else v = static_cast<Type>(x % mod());
        if (v < 0) v += mod();
        return v;
    }

    const Type& operator()() const { return value; }
    template <typename U>
    explicit operator U() const { return static_cast<U>(value); }
    constexpr static Type mod() { return T::value; }

    Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }
    Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }
    template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }
    template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }
    Modular& operator++() { return *this += 1; }
    Modular& operator--() { return *this -= 1; }
    Modular operator++(int) { Modular result(*this); *this += 1; return result; }
    Modular operator--(int) { Modular result(*this); *this -= 1; return result; }
    Modular operator-() const { return Modular(-value); }

    template <typename U = T>
    typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type & operator*=(const Modular& rhs) {
#ifdef _WIN32
        uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);
        uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;
        asm(
            "divl %4; \n\t"
            : "=a" (d), "=d" (m)
            : "d" (xh), "a" (xl), "r" (mod())
        );
        value = m;
#else
        value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));
#endif
        return *this;
    }
    template <typename U = T>
    typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type & operator*=(const Modular& rhs) {
        long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());
        value = normalize(value * rhs.value - q * mod());
        return *this;
    }
    template <typename U = T>
    typename enable_if < !is_integral<typename Modular<U>::Type>::value, Modular >::type & operator*=(const Modular& rhs) {
        value = normalize(value * rhs.value);
        return *this;
    }

    Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }

    friend const Type& abs(const Modular& x) { return x.value; }

    template <typename U>
    friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);

    template <typename U>
    friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);

    template <typename V, typename U>
    friend V& operator>>(V& stream, Modular<U>& number);

private:
    Type value;
};

template <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }
template <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }
template <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }

template <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }
template <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }
template <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }

template <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }

template <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }
template <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }
template <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }

template <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }
template <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }
template <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }

template <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }
template <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }
template <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }

template <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }
template <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }
template <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }

template<typename T, typename U>
Modular<T> power(const Modular<T>& a, const U& b) {
    assert(b >= 0);
    Modular<T> x = a, res = 1;
    U p = b;
    while (p > 0) {
        if (p & 1) res *= x;
        x *= x;
        p >>= 1;
    }
    return res;
}

template <typename T>
bool IsZero(const Modular<T>& number) {
    return number() == 0;
}

template <typename T>
string to_string(const Modular<T>& number) {
    return to_string(number());
}

// U == std::ostream? but done this way because of fastoutput
template <typename U, typename T>
U& operator<<(U& stream, const Modular<T>& number) {
    return stream << number();
}

// U == std::istream? but done this way because of fastinput
template <typename U, typename T>
U& operator>>(U& stream, Modular<T>& number) {
    typename common_type<typename Modular<T>::Type, long long>::type x;
    stream >> x;
    number.value = Modular<T>::normalize(x);
    return stream;
}
constexpr int md = mod1;
using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;*/
/*
using ModType = int;

struct VarMod { static ModType value; };
ModType VarMod::value;
ModType& md = VarMod::value;
using Mint = Modular<VarMod>;
*/
/*
vector<pair<int64_t, int>> G[100005];
void dijkstra(int N, int s, vector<int64_t>& d, vector<int>& p) //dijkstra with path restoration
{
    d.assign(N, 1e12);
    p.assign(N, -1);
    d[s] = 0;
    priority_queue<pair<int64_t, int>, vector<pair<int64_t, int>>, greater<pair<int64_t, int>>> q;
    q.push({0, s});
    while (!q.empty())
    {
        int x = q.top().second;
        int64_t y = q.top().first;
        q.pop();
        for (auto z : G[x])
        {
            int to = z.second;
            int64_t cost = z.first;
            int64_t nz = d[x] + cost;
            if (nz < d[to])
            {
                d[to] = nz;
                p[to] = x;
                q.push({d[to], to});
            }
        }
    }
}
vector<int> restorepath(int s, int t, vector<int> const& p)
{
    vector<int> path;
    for (int v = t; v != s; v = p[v])
    {
        if (v == -1)
        {
            return {};
        }
        path.push_back(v);
    }
    path.push_back(s);
    reverse(path.begin(), path.end());
    return path;
}


vector<int> lps(string& s) {
    int n = s.length();
    vector<int> pi(n);
    for (int i = 1; i < n; i++) {
        int j = pi[i - 1];
        while (j > 0 && s[i] != s[j]) {
            j = pi[j - 1];
        }
        if (s[i] == s[j])j++;
        pi[i] = j;
    }
    return pi;
}

int calculatepqinvmod(int p, int q)
{
    int mod = MOD, expo;
    expo = mod - 2;
    while (expo) {
        if (expo & 1) {
            p = (p * q) % mod;
        }
        q = (q * q) % mod;
        expo >>= 1;
    }
    return p;
}

*/
