/*▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▄░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░██▌░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░▄▄███▀░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░█████░▄█░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░▄████████▀░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒▒░░░░░░░░░░░░░░░░░░░░░░░░▄█████████░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒░░░░░░░░░░░░░░░░░░░░░░░░░░▄███████▌░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒░░░░░░░░░░░░░░░░░░░░░░░░▄█████████░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒░░░░░░░░░░░░░░░░░░░░░▄███████████▌░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒░░░░░░░░░░░░░░░▄▄▄▄██████████████▌░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒░░░░░░░░░░░▄▄███████████████████▌░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒░░░░░░░░░▄██████████████████████▌░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒░░░░░░░░████████████████████████░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒█░░░░░▐██████████▌░▀▀███████████░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▐██░░░▄██████████▌░░░░░░░░░▀██▐█▌░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒██████░█████████ ░░░░░░░░░░▐█▐█▌░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒▒▀▀▀▀░░░██████▀░░░░░░░░░░░░▐█▐█▌░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒▒▒▒▒░░░░▐█████▌░░░░░░░░░░░░▐█▐█▌░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒▒▒▒▒▒░░░░███▀██░░░░░░░░░░░░░█░█▌░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒▒▒▒▒▒▒▒░▐██░░░██░░░░░░░░▄▄████████▄▄▄▄▄▄▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒▒▒▒▒▒▒▒▒██▌░░░░█▄░░░░░░▄███████████████████▄▄▄▄▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
▒▒▒▒▒▒▒▒▒▐██▒▒░░░██▄▄████████████████████████████████████████████
▒▒▒▒▒▒▒▒▒▒▐██▒▒▄█████████████████████████████████████████████████
▒▒▒▒▒▒▒▒▒▒▄▄█████████████████████████████████████████████████████
█████████████████████████████████████████████████████████████████*/
#include <bits/stdc++.h>
using namespace std;
#define  w(t)                      int t;  cin>>t;  while(t--)
#define  mod1                      1000000007
#define  mod2                      998244353
#define  ll                        long long int
#define  ull                       unsigned long long int
#define  fastIO                    ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);
#define  vll                       vector<ll>
#define  vi                        vector<int>
#define  vch                       vector<char>
#define  pll                       pair<ll,ll>
#define  pii                       pair<int,int>
#define  makpii                    make_pair
#define  mpii                      unordered_map<int,int>
#define  sti                       unordered_set<int>
#define  mpci                      unordered_map<char,int>
template<typename T>
T myMax(T x, T y)
{
    return (x > y) ? x : y;
}
struct myComp1          //      sort pairs by second element (MAX)
{
    constexpr bool operator()
    (pair<ll, ll> const& a, pair<ll, ll> const& b)const noexcept
    {
        return a.second < b.second;
    }
};
struct myComp2          //      sort pairs by second element (MIN)
{
    constexpr bool operator()
    (pair<ll, ll> const& a, pair<ll, ll> const& b)const noexcept
    {
        return a.second > b.second;
    }
};
priority_queue<pll, vector<pll>, myComp1> p1; // priority queue with second element in MAX order
priority_queue<pll, vector<pll>, myComp2> p2; // priority queue with second element in MIN order

int32_t main()
{
    fastIO
#ifndef ONLINE_JUDGE
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);
#endif
    w(t)
    {
        cout << "TEST";
    }
    return 0;
}
/*
bool prime[1000001];
int primebeh[1000001];
int primesnear[1000001];
void sieve()
{
    int n = 1000000;
    memset(prime, true, sizeof(prime));
    prime[1]=false;
    for (int p = 2; p * p <= n; p++)
    {
        if (prime[p] == true)
        {
            for (int i = p * p; i <= n; i += p)
                prime[i] = false;
        }
    }
    int last = 0;
    for (int i = 2; i <= n; i++)
    {
        if (prime[i])
        {
            primesnear[i] = i;
            last = i;
        }
        else
        {
            primesnear[i] = last;
        }
    }
    for (int i = n; i >= 2; i--)
    {
        if (prime[i])
        {
            primebeh[i] = i;
            last = i;
        }
        else
        {
            primebeh[i] = last;
        }
    }
}
ll power(ll x, ll y, ll p)
{
    ll res = 1; x = x % p; while (y > 0) {if (y & 1) {res = (res * x) % p;} y = y >> 1; x = (x * x) % p;}
    return res;
}
ll modInverse(ll n, int p)
{
    return power(n, p - 2, p);
}
ll nCrModPFermat(ll n, ll r, ll p)
{
    if (n < r)
        return 0;
    if (r == 0)
        return 1;
    ll fac[n + 1];
    fac[0] = 1;
    for (int i = 1; i <= 1000; i++)
        fac[i] = (fac[i - 1] * i) % mod2;
    return (fac[n] * modInverse(fac[r], p) % p * modInverse(fac[n - r], p) % p) % p;
}
}
vector<pair<ll, ll>> pf;
void factorize(ll n) // finds all prime factors of n and their powers in O(logn)
{
    pf.clear();
    int ct = 0;
    while (n % 2 == 0)
    {
        n /= 2;
        ct++;
    }
    if (ct)
        pf.push_back({2, ct});
    for (ll i = 3; i * i <= n; i += 2)
    {
        ct = 0;
        while (n % i == 0)
        {
            n /= i;
            ct++;
        }
        if (ct)
            pf.push_back({i, ct});
    }
    if (n > 2)
        pf.push_back({n, 1});
}
*/
/*int parent[200005]; DSU
int sz[200005];
void maker_set(int u)
{
    parent[u] = u;
    sz[u] = 1;
}
int find_set(int u)
{
    if (u == parent[u])
        return u;
    return parent[u] = find_set(parent[u]);
}
void union_set(int u, int v)
{
    int a = find_set(u);
    int b = find_set(v);
    if (a != b)
    {
        if (sz[a] < sz[b])
            swap(a, b);
        parent[b] = a;
        sz[a] = sz[a] + sz[b];
    }
}*/
/*const int MAXN = 500005;
int n, q, t[4 * MAXN];
void build(int a[], int v, int l, int r) // O(n) SEGMENT TREE
{
    if (l == r)
    {
        t[v] = a[l];
    }
    else
    {
        int m = (l + r) / 2;
        build(a, 2 * v, l, m);
        build(a, 2 * v + 1, m + 1, r);
        t[v] = t[2 * v] + t[2 * v + 1];
    }
}
int sum(int v, int tl, int tr, int l, int r) // O(logn)
{
    if (l > r)
        return 0;
    if (l == tl && r == tr)
        return t[v];
    int tm = (tl + tr) / 2;
    return sum(2 * v, tl, tm, l, min(r, tm)) + sum(2 * v + 1, tm + 1, tr, max(l, tm + 1), r);
}
void update(int v, int tl, int tr, int pos, int val) // O(logn)
{
    if (tl == tr)
    {
        t[v] += val;
    }
    else
    {
        int tm = (tl + tr) / 2;
        if (pos <= tm)
            update(2 * v, tl, tm, pos, val);
        else
            update(2 * v + 1, tm + 1, tr, pos, val);
        t[v] = t[2 * v] + t[2 * v + 1];
    }
}*/
/*
#define MAXSIEVE 100000000 // All prime numbers up to this  Yarin sieve
#define MAXSIEVEHALF (MAXSIEVE/2)
#define MAXSQRT 5000 // sqrt(MAXSIEVE)/2
char a[MAXSIEVE / 16 + 2];
#define isprime(n) (a[(n)>>4]&(1<<(((n)>>1)&7))) // Works when n is odd
//have to check for even numbers
void sieve()
{
    int i, j;
    memset(a, 255, sizeof(a));
    a[0] = 0xFE;
    for (i = 1; i < MAXSQRT; i++)
        if (a[i >> 3] & (1 << (i & 7)))
            for (j = i + i + i + 1; j < MAXSIEVEHALF; j += i + i + 1)
                a[j >> 3] &= ~(1 << (j & 7));
}
vector<int> adj[200005];
bool visited[200005];
set<int> atdepth[200005];
const int sz = 2e5 + 5;
vector<int> tree[sz];
bool vis[sz];
set<int> path[sz];
void addEdge(int a, int b)
{
    tree[a].push_back(b);
    tree[b].push_back(a);
}
void bfs(int node) // get all paths from root to the node
{
    queue<pair<int, int> > qu;
    qu.push({ node, -1 });
    vis[node] = true;
    while (!qu.empty())
    {
        pair<int, int> p = qu.front();
        qu.pop();
        vis[p.first] = true;
        for (int child : tree[p.first])
        {
            if (!vis[child])
            {
                qu.push({ child, p.first });
                path[child] = path[p.first];
                path[child].insert(p.first);
            }
        }
    }
}
void dfs(int x, int c) // mark all nodes at same depth
{
    visited[x] = true;
    atdepth[c].insert(x);
    for (auto y : adj[x])
    {
        if (!visited[y])
        {
            dfs(y, c + 1);
        }
    }
    if (adj[x].size() == 0)
        atdepth[c].insert(x);
    return;
}*/
/*struct myComp1 //      sort pairs by second element (MAX)
{
    constexpr bool operator()(pair<int, int> const &a, pair<int, int> const &b) const noexcept
    {
        return a.second < b.second;
    }
};
struct myComp2 //      sort pairs by second element (MIN)
{
    constexpr bool operator()(pair<int, int> const &a, pair<int, int> const &b) const noexcept
    {
        return a.second > b.second;
    }
};
struct custom_hash
{
    static uint64_t splitmix64(uint64_t x)
    {
        // http://xorshift.di.unimi.it/splitmix64.c
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }
    size_t operator()(uint64_t x) const
    {
        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x + FIXED_RANDOM);
    }
};
priority_queue<pair<int,int>, vector<pair<int,int>>, myComp1> p1; // priority queue with second element in MAX order
priority_queue<pair<int,int>, vector<pair<int,int>>, myComp2> p2; // priority queue with second element in MIN order*/
/*int ceili(int a, int b)
{
    return a % b == 0 ? (a / b) : (a / b) + 1;
}
int gcd(int a, int b)
{
    if (!a)
        return b;
    return gcd(b % a, a);
}
int power(int x, int y, int p)
{
    int res = 1LL;
    x = x % p;
    while (y > 0)
    {
        if (y & 1)
        {
            res = (res * x) % p;
        }
        y = y >> 1;
        x = (x * x) % p;
    }
    return res;
}
void printVector(vector<int> &vt)
{
    for (auto x : vt)
    {
        cout << x << " ";
    }
    cout << "\n";
}
bool checkpal(string s)
{
    int n = s.length();
    for (int i = 0; i < n; i++)
    {
        if (s[i] != s[n - i - 1])
        {
            return false;
        }
    }
    return true;
}
to check if a point is on in or out of a polygon time complexity O(N)
struct Point
{
    int x;
    int y;
};
bool onSegment(Point p, Point q, Point r)
{
    if (q.x <= max(p.x, r.x) && q.x >= min(p.x, r.x) && q.y <= max(p.y, r.y) && q.y >= min(p.y, r.y))
    {
        return true;
    }
    return false;
}
int orientation(Point p, Point q, Point r)
{
    int val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    if (val == 0)
    {
        return 0;
    }
    return (val > 0) ? 1 : 2;
}
bool doIntersect(Point p1, Point q1, Point p2, Point q2)
{
    int o1 = orientation(p1, q1, p2);
    int o2 = orientation(p1, q1, q2);
    int o3 = orientation(p2, q2, p1);
    int o4 = orientation(p2, q2, q1);
    if (o1 != o2 && o3 != o4)
        return true;
    if (o1 == 0 && onSegment(p1, p2, q1))
    {
        return true;
    }
    if (o2 == 0 && onSegment(p1, q2, q1))
    {
        return true;
    }
    if (o3 == 0 && onSegment(p2, p1, q2))
    {
        return true;
    }
    if (o4 == 0 && onSegment(p2, q1, q2))
    {
        return true;
    }
    return false;
}
bool isInside(Point polygon[], int n, Point p)
{
    if (n < 3)
    {
        return false;
    }
    Point extreme = {INF, p.y};
    int count = 0, i = 0;
    do
    {
        int next = (i + 1) % n;
        if (doIntersect(polygon[i], polygon[next], p, extreme))
        {
            if (orientation(polygon[i], p, polygon[next]) == 0)
                return onSegment(polygon[i], p, polygon[next]);
            count++;
        }
        i = next;
    } while (i != 0);
    return count & 1;
}
struct SparseTable {
    int n, k;
    vector<vector<int64_t>> M;
    vector<int64_t> Log;
    SparseTable(int n) {
        this->n = n;
        this->k = ceil(log2(n)) + 1;
        M.assign(n + 1, vector<int64_t> (k + 1, 0));
        Log.assign(n + 5, 0);
        Log[1] = 0;
        for (int i = 2; i <= n; i++) {
            Log[i] = Log[i / 2] + 1;
        }
    }
    void computationFisMin(vector<int64_t> a) {
        for (int i = 0; i < n; i++) {
            M[i][0] = a[i];
        }
        for (int j = 1; j <= k; j++) {
            for (int i = 0; i + (1 << j) <= n; i++) {
                M[i][j] = min(M[i][j - 1], M[i + (1 << (j - 1))][j - 1]);
            }
        }
    }
    void computationFisSum(vector<int64_t> a) {
        for (int i = 0; i < n; i++) {
            M[i][0] = a[i];
        }
        for (int j = 1; j <= k; j++) {
            for (int i = 0; i + (1 << j) <= n; i++) {
                M[i][j] = (M[i][j - 1] + M[i + (1 << (j - 1))][j - 1]);
            }
        }
    }
    int64_t MinQuery(int l, int r) {
        int j = Log[r - l + 1];
        return min(M[l][j], M[r - (1 << j) + 1][j]);
    }
    int64_t SumQuery(int l, int r) {
        int64_t sum = 0;
        for (int j = k; j >= 0; j--) {
            if ((1 << j) <= (r - l + 1)) {
                sum += M[l][j];
                l += (1 << j);
            }
        }
        return sum;
    }
};
struct FenwickTree {
    vector<int64_t> bit;
    int n;
    FenwickTree(int n) { // O(N)
        this->n = n;
        bit.assign(n, 0);
    }
    FenwickTree(vector<int64_t> a) : FenwickTree(a.size()) {
        for (auto i = 0; i < a.size(); i++) {
            add(i, a[i]);
        }
    }
    int64_t sum(int r) { // O(logN)
        int64_t res = 0;
        for (; r >= 0; r = (r & (r + 1)) - 1) {
            res += bit[r];
        }
        return res;
    }
    int64_t sum(int l, int r) {
        if (l == 0)
            return sum(r);
        else
            return (sum(r) - sum(l - 1));
    }
    void add(int idx, int delta) { // O(logN)
        for (; idx < n; idx = idx | (idx + 1)) {
            bit[idx] += delta;
        }
    }
};
struct SegmentTree {
    int n;
    vector<int64_t> T;
    SegmentTree(int n) {
        this->n = n;
        T.assign(2 * n + 5, 0);
    }
    void UpdateforMin(int k, int x) {
        k += n;
        T[k] = x;
        k = k >> 1;
        while (k >= 1) {
            T[k] = min(T[2 * k], T[2 * k + 1]);
            k = k >> 1;
        }
    }
    void UpdateforSum(int k, int x) {
        k += n;
        x = x - T[k];
        while (k >= 1) {
            T[k] += x;
            k = k >> 1;
        }
    }
    int64_t QueryforSum(int l, int r) {
        l += n; r += n;
        int64_t S = 0;
        while (l <= r) {
            if (l & 1) {
                S += T[l++];
            }
            if (~r & 1) {
                S += T[r--];
            }
            l = l >> 1; r = r >> 1;
        }
        return S;
    }
    int64_t QueryforMin(int l, int r) {
        l += n; r += n;
        int64_t S = INT_MAX;
        while (l <= r) {
            if (l & 1) {
                S = min(S, T[l++]);
            }
            if (~r & 1) {
                S = min(S, T[r--]);
            }
            l = l >> 1; r = r >> 1;
        }
        return S;
    }
};
struct choose {
    int64_t N_;
    vector<int64_t> factorialNumInverse;
    vector<int64_t> naturalNumInverse;
    vector<int64_t> fact;
    choose (int64_t N_) {
        this->N_ = N_;
        factorialNumInverse.assign(N_ + 1, 0);
        naturalNumInverse.assign(N_ + 1, 0);
        fact.assign(N_ + 1, 0);
    }
    void InverseofNumber(int64_t p)
    {
        naturalNumInverse[0] = naturalNumInverse[1] = 1;
        for (int64_t i = 2; i <= N_; i++) {
            naturalNumInverse[i] = naturalNumInverse[p % i] * (p - p / i) % p;
        }
    }
    void InverseofFactorial(int64_t p)
    {
        factorialNumInverse[0] = factorialNumInverse[1] = 1;
        for (int64_t i = 2; i <= N_; i++) {
            factorialNumInverse[i] = (naturalNumInverse[i] * factorialNumInverse[i - 1]) % p;
        }
    }
    void factorial(int64_t p)
    {
        fact[0] = 1;
        for (int64_t i = 1; i <= N_; i++) {
            fact[i] = (fact[i - 1] * i) % p;
        }
    }
    int64_t Binomial(int64_t N, int64_t R, int64_t p)
    {
        int64_t ans = ((fact[N] * factorialNumInverse[R]) % p * factorialNumInverse[N - R]) % p;
        return ans;
    }
};
class LRUCache {
private:
    list<pair<int, int>> lst;
    unordered_map<int, list<pair<int, int>>::iterator> mp;
    int n;
public:
    LRUCache(int cap) {
        this->n = cap;
    }
    int get(int key) {
        if (mp.find(key) == mp.end()) {
            return -1;
        }
        auto it = mp[key];
        int value = it->second;
        lst.erase(it);
        lst.push_front({key, value});
        mp[key] = lst.begin();
        return value;
    }
    void set(int key, int value) {
        if (mp.find(key) == mp.end()) {
            if (lst.size() == n) {
                auto least_used = lst.back();
                mp.erase(least_used.first);
                lst.pop_back();
            }
        }
        else {
            auto it = mp[key];
            lst.erase(it);
        }
        lst.push_front({key, value});
        mp[key] = lst.begin();
    }
};
int64_t pow2lessthanequal(int64_t n) {
    int64_t res = n;
    while ((res & (res - 1))) {
        res = (res & (res - 1));
    }
    return res;
}
int64_t pow2greaterthanequal(int64_t n) {
    int64_t res = n;
    while ((res & (res - 1))) {
        res = (res & (res - 1));
    }
    if (res != n)
        res <<= 1;
    return res;
}*/